<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>U24 Meta Generator</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; max-width: 1000px; margin: 40px auto; padding: 0 20px; background: #f5f5f5; color: #333; }
    h1 { margin-bottom: 8px; }
    .subtitle { color: #666; margin-bottom: 24px; font-size: 14px; }
    label { display: block; font-weight: 600; margin-bottom: 6px; }
    input, textarea { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; font-family: inherit; }
    textarea { min-height: 140px; resize: vertical; }
    .field { margin-bottom: 16px; }
    button { background: #4285f4; color: #fff; border: none; padding: 12px 24px; border-radius: 6px; font-size: 15px; cursor: pointer; }
    button:hover { background: #3367d6; }
    button:disabled { opacity: .5; cursor: not-allowed; }
    .btn-green { background: #34a853; }
    .btn-green:hover { background: #2d9249; }
    .error { color: #d93025; margin-top: 12px; }
    details { margin-bottom: 12px; }
    details summary { cursor: pointer; font-weight: 600; color: #4285f4; font-size: 14px; margin-bottom: 8px; }
    details textarea { min-height: 200px; font-size: 12px; line-height: 1.5; }

    .step { background: #fff; border-radius: 8px; padding: 20px; margin-top: 20px; display: none; }
    .step h2 { margin-bottom: 4px; font-size: 16px; }
    .step .step-desc { color: #666; font-size: 13px; margin-bottom: 12px; }
    .step-num { display: inline-block; background: #4285f4; color: #fff; width: 24px; height: 24px; border-radius: 50%; text-align: center; line-height: 24px; font-size: 12px; font-weight: 700; margin-right: 8px; }
    .step-num.done { background: #34a853; }
    .step-num.active { background: #ea8600; }

    .spinner { display: inline-block; width: 16px; height: 16px; border: 2px solid #ccc; border-top-color: #4285f4; border-radius: 50%; animation: spin .6s linear infinite; vertical-align: middle; margin-right: 6px; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Keywords display */
    .kw-list { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; }
    .kw-tag { background: #e8eaf6; padding: 4px 10px; border-radius: 4px; font-size: 13px; font-family: monospace; }

    /* Keyword table */
    table { width: 100%; border-collapse: collapse; font-size: 13px; margin-top: 8px; }
    th, td { padding: 8px 10px; text-align: left; border-bottom: 1px solid #eee; }
    th { background: #f8f9fa; font-weight: 600; }
    .badge { display: inline-block; padding: 2px 8px; border-radius: 10px; font-size: 11px; font-weight: 600; }
    .badge-low { background: #e8f5e9; color: #2e7d32; }
    .badge-med { background: #fff3e0; color: #e65100; }
    .badge-high { background: #fce4ec; color: #c62828; }

    /* Selection cards */
    .option-cards { display: flex; flex-direction: column; gap: 12px; margin-top: 12px; }
    .option-card { border: 2px solid #e0e0e0; border-radius: 10px; padding: 16px; cursor: pointer; transition: all .15s; background: #fff; }
    .option-card:hover { border-color: #4285f4; box-shadow: 0 2px 8px rgba(66,133,244,.15); }
    .option-card.selected { border-color: #34a853; background: #e8f5e9; }
    .option-card.confirmed { cursor: default; }
    .option-card .option-label { font-weight: 700; color: #666; margin-bottom: 8px; font-size: 13px; display: flex; justify-content: space-between; align-items: center; }
    .option-card .chosen-badge { background: #34a853; color: #fff; padding: 2px 8px; border-radius: 10px; font-size: 11px; }

    .meta-title { font-size: 15px; font-weight: 700; color: #1a0dab; }
    .meta-desc { font-size: 13px; color: #4d5156; margin-top: 2px; }
    .meta-chars { font-size: 11px; color: #888; margin-top: 4px; }
    .char-warn { color: #d93025; font-weight: 600; }

    .actions { margin-top: 16px; display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .info-text { color: #888; font-size: 13px; }
    .success-text { color: #34a853; font-weight: 600; font-size: 13px; }

    /* Final result */
    .final-result { background: #e8f5e9; border-radius: 8px; padding: 16px; margin-top: 16px; }
    .final-result h3 { font-size: 14px; margin-bottom: 12px; color: #2e7d32; }
    .final-result .result-title { font-size: 18px; font-weight: 700; color: #1a0dab; margin-bottom: 4px; }
    .final-result .result-desc { font-size: 14px; color: #4d5156; }
    .final-result .result-chars { font-size: 12px; color: #888; margin-top: 6px; }
  </style>
</head>
<body>
  <h1>United24 Media — Meta Generator</h1>
  <p class="subtitle">Paste an article, get keyword data, then choose your SEO title and description.</p>

  <div class="field">
    <label>Article Text</label>
    <textarea id="content" placeholder="Paste your full article text here..."></textarea>
  </div>

  <details>
    <summary>Edit Keyword Extraction Prompt</summary>
    <textarea id="kwPrompt">You are an SEO keyword research specialist. Extract 5-8 SHORT SEED KEYWORDS to check search volume via API.

## Rules
- 1-3 words ONLY (shorter = better)
- CORE TOPICS, not full phrases
- What would an ENGLISH-SPEAKING reader Google?
- Include: weapon names, country names, military terms, proper nouns
- Lowercase, English only, no articles (a, an, the)

## Output
JSON array only. No markdown, no explanation.
["keyword one", "keyword two", "keyword three"]</textarea>
  </details>

  <details>
    <summary>Edit Meta Generation Prompt</summary>
    <textarea id="metaPrompt"># United24 Media Meta Generator

You are a Senior SEO Editor for United24 Media, covering the Russia-Ukraine war.

## Brand Voice
- Use specific numbers ($4B, 71%, 340 drones)
- Active verbs: Confirms, Reveals, Warns, Liquidates, Strikes
- NO hyperbolic adjectives, clickbait, or em-dashes in titles

## Title rules
45-60 characters. Primary keyword in first 3-4 words.

## Description rules
150-160 characters. Compelling, informative.</textarea>
  </details>

  <button id="runBtn" onclick="startGeneration()">Generate Meta</button>
  <div id="error" class="error"></div>

  <!-- Step 1: Keyword extraction (auto) -->
  <div class="step" id="step1">
    <h2><span class="step-num" id="s1n">1</span> Keyword Extraction</h2>
    <p class="step-desc">Gemini extracts keywords from the article</p>
    <div id="step1out"></div>
  </div>

  <!-- Step 2: DataForSEO -->
  <div class="step" id="step2">
    <h2><span class="step-num" id="s2n">2</span> Keyword Volume Data (DataForSEO)</h2>
    <p class="step-desc">Getting real search volumes for extracted keywords</p>
    <div id="step2out"></div>
  </div>

  <!-- Step 3: Title selection -->
  <div class="step" id="step3">
    <h2><span class="step-num" id="s3n">3</span> Choose SEO Title</h2>
    <p class="step-desc">Pick the best title for your article</p>
    <div id="step3out"></div>
  </div>

  <!-- Step 4: Description selection -->
  <div class="step" id="step4">
    <h2><span class="step-num" id="s4n">4</span> Choose SEO Description</h2>
    <p class="step-desc">Pick the best description for your article</p>
    <div id="step4out"></div>
  </div>

  <script>
    const CONFIG = {
      proxyUrl: 'https://wild-forest-71d3.slobodskyi.workers.dev/'
    };

    // State
    let state = {
      keywords: [],
      kwData: [],
      titles: [],
      selectedTitle: null,
      titleConfirmed: false,
      descriptions: [],
      selectedDesc: null,
      descConfirmed: false
    };

    function show(id) { document.getElementById(id).style.display = 'block'; }
    function hide(id) { document.getElementById(id).style.display = 'none'; }
    function setStepState(id, s) {
      document.getElementById(id).className = 'step-num' + (s === 'active' ? ' active' : s === 'done' ? ' done' : '');
    }

    // ─── API CALLS via Cloudflare Worker Proxy ───
    async function callGemini(prompt) {
      const res = await fetch(CONFIG.proxyUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ service: 'gemini', prompt })
      });
      if (!res.ok) {
        const err = await res.json().catch(() => ({}));
        throw new Error(`Gemini: ${err.error || res.status}`);
      }
      const data = await res.json();
      if (data.error) throw new Error(`Gemini: ${data.error}`);
      return data.text || '';
    }

    async function dfsPost(endpoint, body) {
      const res = await fetch(CONFIG.proxyUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ service: 'dataforseo', endpoint, data: body })
      });
      if (!res.ok) throw new Error('DataForSEO: HTTP ' + res.status);
      const data = await res.json();
      if (data.status_code !== 20000) throw new Error('DataForSEO: ' + data.status_message);
      const task = data.tasks?.[0];
      if (task?.status_code !== 20000) throw new Error('DataForSEO task: ' + task?.status_message);
      return task?.result || [];
    }

    function parseJSON(raw, type = 'array') {
      try {
        const regex = type === 'array' ? /\[[\s\S]*?\]/ : /\{[\s\S]*\}/;
        const m = raw.match(regex);
        if (m) return JSON.parse(m[0]);
      } catch (_) {}
      return null;
    }

    // ─── STEP 1: KEYWORD EXTRACTION (auto via Gemini) ───
    async function runStep1(content) {
      show('step1');
      setStepState('s1n', 'active');
      const out = document.getElementById('step1out');
      out.innerHTML = '<span class="spinner"></span> Gemini is extracting keywords...';

      const kwPrompt = document.getElementById('kwPrompt').value.trim();
      const fullPrompt = `${kwPrompt}\n\n## Article:\n${content.substring(0, 4000)}`;

      const raw = await callGemini(fullPrompt);
      console.log('Keyword raw:', raw);

      let kws = parseJSON(raw, 'array') || [];
      kws = kws.map(k => typeof k === 'object' ? k.keyword : String(k)).filter(Boolean);

      if (kws.length === 0) {
        throw new Error('Gemini failed to extract keywords. Check console.');
      }

      state.keywords = kws;

      out.innerHTML = '<div class="kw-list">' + kws.map(k => `<span class="kw-tag">${k}</span>`).join('') + '</div>';
      setStepState('s1n', 'done');
    }

    // ─── STEP 2: DATAFORSEO ───
    async function runStep2() {
      show('step2');
      setStepState('s2n', 'active');
      const out = document.getElementById('step2out');
      out.innerHTML = `<span class="spinner"></span> Getting volume data for: ${state.keywords.join(', ')}...`;

      try {
        let allKw = [];

        // Get Google suggestions
        try {
          const suggestions = await dfsPost('keywords_data/google_ads/keywords_for_keywords/live', [{
            keywords: state.keywords,
            language_name: 'English',
            location_name: 'United States',
            sort_by: 'search_volume'
          }]);
          allKw = suggestions.slice(0, 15).map(r => ({
            keyword: r.keyword,
            search_volume: r.search_volume,
            competition: r.competition,
            cpc: r.cpc
          }));
        } catch (e) {
          console.error('Suggestions failed:', e);
        }

        // Get seed volumes
        try {
          const seeds = await dfsPost('keywords_data/google_ads/search_volume/live', [{
            keywords: state.keywords,
            language_name: 'English',
            location_name: 'United States'
          }]);
          for (const r of seeds) {
            if (!allKw.find(k => k.keyword.toLowerCase() === r.keyword.toLowerCase())) {
              allKw.unshift({ keyword: r.keyword, search_volume: r.search_volume, competition: r.competition, cpc: r.cpc });
            }
          }
        } catch (e) {
          console.error('Seed volume failed:', e);
        }

        allKw.sort((a, b) => (b.search_volume || 0) - (a.search_volume || 0));
        state.kwData = allKw;

        if (allKw.length) {
          let tableHtml = `<table><tr><th>Keyword</th><th>Volume</th><th>Competition</th><th>CPC</th></tr>`;
          for (const kw of allKw.slice(0, 12)) {
            const comp = (kw.competition || '').toUpperCase();
            const badge = comp === 'LOW' ? 'badge-low' : comp === 'MEDIUM' ? 'badge-med' : 'badge-high';
            tableHtml += `<tr><td>${kw.keyword}</td><td>${(kw.search_volume || 0).toLocaleString()}</td><td><span class="badge ${badge}">${kw.competition || '?'}</span></td><td>$${(kw.cpc || 0).toFixed(2)}</td></tr>`;
          }
          tableHtml += '</table>';
          out.innerHTML = tableHtml;
        } else {
          out.innerHTML = '<p style="color:#888">No volume data available. Proceeding with keywords only.</p>';
        }

        setStepState('s2n', 'done');

      } catch (e) {
        out.innerHTML = `<div class="error">${e.message}</div>`;
        setStepState('s2n', 'done');
      }
    }

    // ─── STEP 3: TITLE GENERATION & SELECTION ───
    async function runStep3(content) {
      show('step3');
      setStepState('s3n', 'active');
      const out = document.getElementById('step3out');
      out.innerHTML = '<span class="spinner"></span> Gemini is generating SEO titles...';

      const metaPrompt = document.getElementById('metaPrompt').value.trim();

      // Build keyword context
      let kwContext = `## Keywords to use:\n${state.keywords.map(k => `- "${k}"`).join('\n')}`;
      if (state.kwData.length) {
        const top5 = state.kwData.slice(0, 5);
        kwContext += `\n\n## Search Volume Data:\n${top5.map(k => `- "${k.keyword}" — ${k.search_volume?.toLocaleString() || '?'} monthly searches`).join('\n')}`;
        kwContext += `\n\nPRIMARY keyword (highest volume): "${top5[0].keyword}"`;
      }

      const titlePrompt = `${metaPrompt}

## Task
Generate exactly 3 DIFFERENT SEO titles for this article.
Each title should take a different angle or emphasis.

${kwContext}

## Article:
${content.substring(0, 4000)}

## Output Format (STRICT)
Return ONLY this JSON array with exactly 3 titles:
["First title option", "Second title option", "Third title option"]`;

      const raw = await callGemini(titlePrompt);
      console.log('Title raw:', raw);

      let titles = parseJSON(raw, 'array');
      if (!titles || !Array.isArray(titles) || titles.length < 3) {
        throw new Error('Gemini failed to generate 3 titles. Check console.');
      }
      titles = titles.slice(0, 3);
      state.titles = titles;

      renderTitleCards();
      setStepState('s3n', 'done');
    }

    function renderTitleCards() {
      const out = document.getElementById('step3out');
      let html = '<div class="option-cards">';

      state.titles.forEach((title, i) => {
        const isSelected = state.selectedTitle === i;
        const isChosen = state.titleConfirmed && isSelected;
        const tLen = title.length;
        const tWarn = tLen < 45 || tLen > 60;

        html += `<div class="option-card${isSelected ? ' selected' : ''}${state.titleConfirmed ? ' confirmed' : ''}" onclick="selectTitle(${i})">
          <div class="option-label">
            Option ${i + 1}
            ${isChosen ? '<span class="chosen-badge">CHOSEN</span>' : ''}
          </div>
          <div class="meta-title">${title}</div>
          <div class="meta-chars"><span class="${tWarn ? 'char-warn' : ''}">${tLen} characters</span></div>
        </div>`;
      });

      html += '</div>';
      html += `<div class="actions">
        ${!state.titleConfirmed ?
          `<button onclick="confirmTitle()" class="btn-green" ${state.selectedTitle === null ? 'disabled' : ''}>Confirm Title</button>
          <span class="info-text">Select your preferred title</span>` :
          `<span class="success-text">Title confirmed!</span>`}
      </div>`;

      out.innerHTML = html;
    }

    function selectTitle(index) {
      if (state.titleConfirmed) return;
      state.selectedTitle = index;
      renderTitleCards();
    }

    async function confirmTitle() {
      if (state.selectedTitle === null || state.titleConfirmed) return;
      state.titleConfirmed = true;
      renderTitleCards();

      // Proceed to descriptions
      const content = document.getElementById('content').value.trim();
      await runStep4(content);
    }

    // ─── STEP 4: DESCRIPTION GENERATION & SELECTION ───
    async function runStep4(content) {
      show('step4');
      setStepState('s4n', 'active');
      const out = document.getElementById('step4out');
      out.innerHTML = '<span class="spinner"></span> Gemini is generating SEO descriptions...';

      const metaPrompt = document.getElementById('metaPrompt').value.trim();
      const chosenTitle = state.titles[state.selectedTitle];

      // Build keyword context
      let kwContext = `## Keywords to use:\n${state.keywords.map(k => `- "${k}"`).join('\n')}`;
      if (state.kwData.length) {
        const top5 = state.kwData.slice(0, 5);
        kwContext += `\n\n## Search Volume Data:\n${top5.map(k => `- "${k.keyword}" — ${k.search_volume?.toLocaleString() || '?'} monthly searches`).join('\n')}`;
        kwContext += `\n\nPRIMARY keyword (highest volume): "${top5[0].keyword}"`;
      }

      const descPrompt = `${metaPrompt}

## Task
The chosen SEO title is: "${chosenTitle}"

Generate exactly 3 DIFFERENT SEO meta descriptions for this article that complement the title above.
Each description should take a different angle or emphasis.

${kwContext}

## Article:
${content.substring(0, 4000)}

## Output Format (STRICT)
Return ONLY this JSON array with exactly 3 descriptions:
["First description option", "Second description option", "Third description option"]`;

      const raw = await callGemini(descPrompt);
      console.log('Description raw:', raw);

      let descriptions = parseJSON(raw, 'array');
      if (!descriptions || !Array.isArray(descriptions) || descriptions.length < 3) {
        throw new Error('Gemini failed to generate 3 descriptions. Check console.');
      }
      descriptions = descriptions.slice(0, 3);
      state.descriptions = descriptions;

      renderDescCards();
      setStepState('s4n', 'done');
    }

    function renderDescCards() {
      const out = document.getElementById('step4out');
      let html = '<div class="option-cards">';

      state.descriptions.forEach((desc, i) => {
        const isSelected = state.selectedDesc === i;
        const isChosen = state.descConfirmed && isSelected;
        const dLen = desc.length;
        const dWarn = dLen < 150 || dLen > 160;

        html += `<div class="option-card${isSelected ? ' selected' : ''}${state.descConfirmed ? ' confirmed' : ''}" onclick="selectDesc(${i})">
          <div class="option-label">
            Option ${i + 1}
            ${isChosen ? '<span class="chosen-badge">CHOSEN</span>' : ''}
          </div>
          <div class="meta-desc">${desc}</div>
          <div class="meta-chars"><span class="${dWarn ? 'char-warn' : ''}">${dLen} characters</span></div>
        </div>`;
      });

      html += '</div>';
      html += `<div class="actions">
        ${!state.descConfirmed ?
          `<button onclick="confirmDesc()" class="btn-green" ${state.selectedDesc === null ? 'disabled' : ''}>Confirm Description</button>
          <span class="info-text">Select your preferred description</span>` :
          `<span class="success-text">Description confirmed!</span>`}
      </div>`;

      // Show final result if both confirmed
      if (state.descConfirmed) {
        const chosenTitle = state.titles[state.selectedTitle];
        const chosenDesc = state.descriptions[state.selectedDesc];
        html += `<div class="final-result">
          <h3>Your Final Meta Tags</h3>
          <div class="result-title">${chosenTitle}</div>
          <div class="result-chars">${chosenTitle.length} characters</div>
          <div style="margin-top:12px">
            <div class="result-desc">${chosenDesc}</div>
            <div class="result-chars">${chosenDesc.length} characters</div>
          </div>
        </div>`;
      }

      out.innerHTML = html;
    }

    function selectDesc(index) {
      if (state.descConfirmed) return;
      state.selectedDesc = index;
      renderDescCards();
    }

    function confirmDesc() {
      if (state.selectedDesc === null || state.descConfirmed) return;
      state.descConfirmed = true;
      renderDescCards();
    }

    // ─── MAIN START ───
    async function startGeneration() {
      const content = document.getElementById('content').value.trim();
      const errorEl = document.getElementById('error');
      const btn = document.getElementById('runBtn');

      errorEl.textContent = '';
      if (!content) { errorEl.textContent = 'Article text required.'; return; }

      // Reset state
      state = {
        keywords: [],
        kwData: [],
        titles: [],
        selectedTitle: null,
        titleConfirmed: false,
        descriptions: [],
        selectedDesc: null,
        descConfirmed: false
      };
      hide('step2');
      hide('step3');
      hide('step4');

      btn.disabled = true;
      btn.textContent = 'Running...';

      try {
        // Step 1: Gemini extracts keywords
        await runStep1(content);

        // Step 2: DataForSEO volumes
        await runStep2();

        // Step 3: Generate titles
        await runStep3(content);

      } catch (e) {
        errorEl.textContent = e.message;
        console.error('Error:', e);
      } finally {
        btn.disabled = false;
        btn.textContent = 'Generate Meta';
      }
    }
  </script>
</body>
</html>
